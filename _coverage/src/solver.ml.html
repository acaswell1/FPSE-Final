<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Coverage report</title>
    <link rel="stylesheet" href="../coverage.css" />
    <script src="../highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <meta charset="utf-8" />
  </head>
  <body>
    <div id="header">
      <h1>
        <a href="../index.html">
          <span class="dirname">src/</span>solver.ml
        </a>
      </h1>
      <h2>98.19%</h2>
    </div>
    <div id="navbar">
      <span class="unvisited" style="top:44.89%"></span>
      <span class="unvisited" style="bottom:30.03%"></span>
      <span class="unvisited" style="bottom:21.98%"></span>
      <span class="unvisited" style="bottom:0.62%"></span>
    </div>
    <div id="report">
      <div id="lines-layer">
        <pre>
<a id="L1"></a><span class="visited"> </span>
<a id="L2"></a><span > </span>
<a id="L3"></a><span > </span>
<a id="L4"></a><span > </span>
<a id="L5"></a><span > </span>
<a id="L6"></a><span > </span>
<a id="L7"></a><span > </span>
<a id="L8"></a><span > </span>
<a id="L9"></a><span > </span>
<a id="L10"></a><span > </span>
<a id="L11"></a><span > </span>
<a id="L12"></a><span > </span>
<a id="L13"></a><span > </span>
<a id="L14"></a><span > </span>
<a id="L15"></a><span > </span>
<a id="L16"></a><span class="visited"> </span>
<a id="L17"></a><span class="visited"> </span>
<a id="L18"></a><span > </span>
<a id="L19"></a><span > </span>
<a id="L20"></a><span class="visited"> </span>
<a id="L21"></a><span > </span>
<a id="L22"></a><span > </span>
<a id="L23"></a><span > </span>
<a id="L24"></a><span class="visited"> </span>
<a id="L25"></a><span > </span>
<a id="L26"></a><span > </span>
<a id="L27"></a><span > </span>
<a id="L28"></a><span > </span>
<a id="L29"></a><span > </span>
<a id="L30"></a><span > </span>
<a id="L31"></a><span > </span>
<a id="L32"></a><span > </span>
<a id="L33"></a><span > </span>
<a id="L34"></a><span > </span>
<a id="L35"></a><span class="visited"> </span>
<a id="L36"></a><span > </span>
<a id="L37"></a><span class="visited"> </span>
<a id="L38"></a><span class="visited"> </span>
<a id="L39"></a><span class="visited"> </span>
<a id="L40"></a><span class="visited"> </span>
<a id="L41"></a><span class="visited"> </span>
<a id="L42"></a><span class="visited"> </span>
<a id="L43"></a><span > </span>
<a id="L44"></a><span > </span>
<a id="L45"></a><span > </span>
<a id="L46"></a><span > </span>
<a id="L47"></a><span > </span>
<a id="L48"></a><span > </span>
<a id="L49"></a><span > </span>
<a id="L50"></a><span class="visited"> </span>
<a id="L51"></a><span > </span>
<a id="L52"></a><span class="visited"> </span>
<a id="L53"></a><span > </span>
<a id="L54"></a><span > </span>
<a id="L55"></a><span > </span>
<a id="L56"></a><span > </span>
<a id="L57"></a><span > </span>
<a id="L58"></a><span > </span>
<a id="L59"></a><span > </span>
<a id="L60"></a><span > </span>
<a id="L61"></a><span > </span>
<a id="L62"></a><span > </span>
<a id="L63"></a><span > </span>
<a id="L64"></a><span > </span>
<a id="L65"></a><span > </span>
<a id="L66"></a><span > </span>
<a id="L67"></a><span > </span>
<a id="L68"></a><span > </span>
<a id="L69"></a><span > </span>
<a id="L70"></a><span class="visited"> </span>
<a id="L71"></a><span class="visited"> </span>
<a id="L72"></a><span > </span>
<a id="L73"></a><span > </span>
<a id="L74"></a><span > </span>
<a id="L75"></a><span > </span>
<a id="L76"></a><span > </span>
<a id="L77"></a><span > </span>
<a id="L78"></a><span > </span>
<a id="L79"></a><span class="visited"> </span>
<a id="L80"></a><span > </span>
<a id="L81"></a><span class="visited"> </span>
<a id="L82"></a><span > </span>
<a id="L83"></a><span > </span>
<a id="L84"></a><span > </span>
<a id="L85"></a><span > </span>
<a id="L86"></a><span > </span>
<a id="L87"></a><span > </span>
<a id="L88"></a><span > </span>
<a id="L89"></a><span > </span>
<a id="L90"></a><span > </span>
<a id="L91"></a><span > </span>
<a id="L92"></a><span > </span>
<a id="L93"></a><span > </span>
<a id="L94"></a><span > </span>
<a id="L95"></a><span > </span>
<a id="L96"></a><span > </span>
<a id="L97"></a><span class="visited"> </span>
<a id="L98"></a><span class="visited"> </span>
<a id="L99"></a><span > </span>
<a id="L100"></a><span > </span>
<a id="L101"></a><span > </span>
<a id="L102"></a><span > </span>
<a id="L103"></a><span > </span>
<a id="L104"></a><span class="visited"> </span>
<a id="L105"></a><span class="visited"> </span>
<a id="L106"></a><span class="visited"> </span>
<a id="L107"></a><span > </span>
<a id="L108"></a><span > </span>
<a id="L109"></a><span > </span>
<a id="L110"></a><span > </span>
<a id="L111"></a><span > </span>
<a id="L112"></a><span > </span>
<a id="L113"></a><span > </span>
<a id="L114"></a><span > </span>
<a id="L115"></a><span > </span>
<a id="L116"></a><span > </span>
<a id="L117"></a><span > </span>
<a id="L118"></a><span > </span>
<a id="L119"></a><span > </span>
<a id="L120"></a><span > </span>
<a id="L121"></a><span class="visited"> </span>
<a id="L122"></a><span class="visited"> </span>
<a id="L123"></a><span > </span>
<a id="L124"></a><span > </span>
<a id="L125"></a><span class="visited"> </span>
<a id="L126"></a><span > </span>
<a id="L127"></a><span > </span>
<a id="L128"></a><span > </span>
<a id="L129"></a><span > </span>
<a id="L130"></a><span class="visited"> </span>
<a id="L131"></a><span class="visited"> </span>
<a id="L132"></a><span > </span>
<a id="L133"></a><span > </span>
<a id="L134"></a><span > </span>
<a id="L135"></a><span > </span>
<a id="L136"></a><span class="visited"> </span>
<a id="L137"></a><span class="visited"> </span>
<a id="L138"></a><span > </span>
<a id="L139"></a><span > </span>
<a id="L140"></a><span class="visited"> </span>
<a id="L141"></a><span class="visited"> </span>
<a id="L142"></a><span class="visited"> </span>
<a id="L143"></a><span class="visited"> </span>
<a id="L144"></a><span class="visited"> </span>
<a id="L145"></a><span class="unvisited"> </span>
<a id="L146"></a><span > </span>
<a id="L147"></a><span class="visited"> </span>
<a id="L148"></a><span class="visited"> </span>
<a id="L149"></a><span class="visited"> </span>
<a id="L150"></a><span class="visited"> </span>
<a id="L151"></a><span > </span>
<a id="L152"></a><span > </span>
<a id="L153"></a><span > </span>
<a id="L154"></a><span > </span>
<a id="L155"></a><span > </span>
<a id="L156"></a><span > </span>
<a id="L157"></a><span > </span>
<a id="L158"></a><span > </span>
<a id="L159"></a><span > </span>
<a id="L160"></a><span > </span>
<a id="L161"></a><span > </span>
<a id="L162"></a><span > </span>
<a id="L163"></a><span > </span>
<a id="L164"></a><span > </span>
<a id="L165"></a><span > </span>
<a id="L166"></a><span class="visited"> </span>
<a id="L167"></a><span > </span>
<a id="L168"></a><span > </span>
<a id="L169"></a><span > </span>
<a id="L170"></a><span > </span>
<a id="L171"></a><span > </span>
<a id="L172"></a><span class="visited"> </span>
<a id="L173"></a><span > </span>
<a id="L174"></a><span > </span>
<a id="L175"></a><span > </span>
<a id="L176"></a><span > </span>
<a id="L177"></a><span > </span>
<a id="L178"></a><span > </span>
<a id="L179"></a><span > </span>
<a id="L180"></a><span > </span>
<a id="L181"></a><span class="visited"> </span>
<a id="L182"></a><span class="visited"> </span>
<a id="L183"></a><span class="visited"> </span>
<a id="L184"></a><span class="visited"> </span>
<a id="L185"></a><span class="visited"> </span>
<a id="L186"></a><span > </span>
<a id="L187"></a><span > </span>
<a id="L188"></a><span > </span>
<a id="L189"></a><span > </span>
<a id="L190"></a><span > </span>
<a id="L191"></a><span > </span>
<a id="L192"></a><span class="visited"> </span>
<a id="L193"></a><span class="visited"> </span>
<a id="L194"></a><span class="visited"> </span>
<a id="L195"></a><span > </span>
<a id="L196"></a><span > </span>
<a id="L197"></a><span > </span>
<a id="L198"></a><span > </span>
<a id="L199"></a><span > </span>
<a id="L200"></a><span > </span>
<a id="L201"></a><span class="visited"> </span>
<a id="L202"></a><span class="visited"> </span>
<a id="L203"></a><span > </span>
<a id="L204"></a><span class="visited"> </span>
<a id="L205"></a><span class="visited"> </span>
<a id="L206"></a><span > </span>
<a id="L207"></a><span > </span>
<a id="L208"></a><span > </span>
<a id="L209"></a><span > </span>
<a id="L210"></a><span > </span>
<a id="L211"></a><span > </span>
<a id="L212"></a><span > </span>
<a id="L213"></a><span > </span>
<a id="L214"></a><span > </span>
<a id="L215"></a><span > </span>
<a id="L216"></a><span > </span>
<a id="L217"></a><span > </span>
<a id="L218"></a><span > </span>
<a id="L219"></a><span > </span>
<a id="L220"></a><span class="visited"> </span>
<a id="L221"></a><span class="visited"> </span>
<a id="L222"></a><span class="visited"> </span>
<a id="L223"></a><span class="visited"> </span>
<a id="L224"></a><span class="visited"> </span>
<a id="L225"></a><span class="visited"> </span>
<a id="L226"></a><span class="unvisited"> </span>
<a id="L227"></a><span > </span>
<a id="L228"></a><span > </span>
<a id="L229"></a><span > </span>
<a id="L230"></a><span > </span>
<a id="L231"></a><span > </span>
<a id="L232"></a><span > </span>
<a id="L233"></a><span > </span>
<a id="L234"></a><span class="visited"> </span>
<a id="L235"></a><span class="visited"> </span>
<a id="L236"></a><span > </span>
<a id="L237"></a><span class="visited"> </span>
<a id="L238"></a><span class="visited"> </span>
<a id="L239"></a><span > </span>
<a id="L240"></a><span > </span>
<a id="L241"></a><span > </span>
<a id="L242"></a><span > </span>
<a id="L243"></a><span > </span>
<a id="L244"></a><span > </span>
<a id="L245"></a><span > </span>
<a id="L246"></a><span class="visited"> </span>
<a id="L247"></a><span class="visited"> </span>
<a id="L248"></a><span class="visited"> </span>
<a id="L249"></a><span class="visited"> </span>
<a id="L250"></a><span class="visited"> </span>
<a id="L251"></a><span class="visited"> </span>
<a id="L252"></a><span class="unvisited"> </span>
<a id="L253"></a><span > </span>
<a id="L254"></a><span > </span>
<a id="L255"></a><span > </span>
<a id="L256"></a><span > </span>
<a id="L257"></a><span class="visited"> </span>
<a id="L258"></a><span class="visited"> </span>
<a id="L259"></a><span > </span>
<a id="L260"></a><span > </span>
<a id="L261"></a><span > </span>
<a id="L262"></a><span > </span>
<a id="L263"></a><span class="visited"> </span>
<a id="L264"></a><span class="visited"> </span>
<a id="L265"></a><span class="visited"> </span>
<a id="L266"></a><span class="visited"> </span>
<a id="L267"></a><span class="visited"> </span>
<a id="L268"></a><span class="visited"> </span>
<a id="L269"></a><span class="visited"> </span>
<a id="L270"></a><span class="visited"> </span>
<a id="L271"></a><span class="visited"> </span>
<a id="L272"></a><span class="visited"> </span>
<a id="L273"></a><span class="visited"> </span>
<a id="L274"></a><span class="visited"> </span>
<a id="L275"></a><span class="visited"> </span>
<a id="L276"></a><span class="visited"> </span>
<a id="L277"></a><span class="visited"> </span>
<a id="L278"></a><span class="visited"> </span>
<a id="L279"></a><span class="visited"> </span>
<a id="L280"></a><span class="visited"> </span>
<a id="L281"></a><span class="visited"> </span>
<a id="L282"></a><span class="visited"> </span>
<a id="L283"></a><span class="visited"> </span>
<a id="L284"></a><span class="visited"> </span>
<a id="L285"></a><span class="visited"> </span>
<a id="L286"></a><span class="visited"> </span>
<a id="L287"></a><span class="visited"> </span>
<a id="L288"></a><span class="visited"> </span>
<a id="L289"></a><span > </span>
<a id="L290"></a><span > </span>
<a id="L291"></a><span > </span>
<a id="L292"></a><span > </span>
<a id="L293"></a><span class="visited"> </span>
<a id="L294"></a><span class="visited"> </span>
<a id="L295"></a><span class="visited"> </span>
<a id="L296"></a><span class="visited"> </span>
<a id="L297"></a><span > </span>
<a id="L298"></a><span > </span>
<a id="L299"></a><span class="visited"> </span>
<a id="L300"></a><span class="visited"> </span>
<a id="L301"></a><span > </span>
<a id="L302"></a><span > </span>
<a id="L303"></a><span class="visited"> </span>
<a id="L304"></a><span class="visited"> </span>
<a id="L305"></a><span class="visited"> </span>
<a id="L306"></a><span class="visited"> </span>
<a id="L307"></a><span class="visited"> </span>
<a id="L308"></a><span class="visited"> </span>
<a id="L309"></a><span class="visited"> </span>
<a id="L310"></a><span class="visited"> </span>
<a id="L311"></a><span > </span>
<a id="L312"></a><span > </span>
<a id="L313"></a><span > </span>
<a id="L314"></a><span class="visited"> </span>
<a id="L315"></a><span > </span>
<a id="L316"></a><span class="visited"> </span>
<a id="L317"></a><span > </span>
<a id="L318"></a><span > </span>
<a id="L319"></a><span class="visited"> </span>
<a id="L320"></a><span class="visited"> </span>
<a id="L321"></a><span class="unvisited"> </span>
<a id="L322"></a><span class="visited"> </span>
<a id="L323"></a><span > </span>
</pre>
      </div>
      <div id="text-layer">
        <pre id="line-numbers">
<a href="#L1">  1</a>
<a href="#L2">  2</a>
<a href="#L3">  3</a>
<a href="#L4">  4</a>
<a href="#L5">  5</a>
<a href="#L6">  6</a>
<a href="#L7">  7</a>
<a href="#L8">  8</a>
<a href="#L9">  9</a>
<a href="#L10"> 10</a>
<a href="#L11"> 11</a>
<a href="#L12"> 12</a>
<a href="#L13"> 13</a>
<a href="#L14"> 14</a>
<a href="#L15"> 15</a>
<a href="#L16"> 16</a>
<a href="#L17"> 17</a>
<a href="#L18"> 18</a>
<a href="#L19"> 19</a>
<a href="#L20"> 20</a>
<a href="#L21"> 21</a>
<a href="#L22"> 22</a>
<a href="#L23"> 23</a>
<a href="#L24"> 24</a>
<a href="#L25"> 25</a>
<a href="#L26"> 26</a>
<a href="#L27"> 27</a>
<a href="#L28"> 28</a>
<a href="#L29"> 29</a>
<a href="#L30"> 30</a>
<a href="#L31"> 31</a>
<a href="#L32"> 32</a>
<a href="#L33"> 33</a>
<a href="#L34"> 34</a>
<a href="#L35"> 35</a>
<a href="#L36"> 36</a>
<a href="#L37"> 37</a>
<a href="#L38"> 38</a>
<a href="#L39"> 39</a>
<a href="#L40"> 40</a>
<a href="#L41"> 41</a>
<a href="#L42"> 42</a>
<a href="#L43"> 43</a>
<a href="#L44"> 44</a>
<a href="#L45"> 45</a>
<a href="#L46"> 46</a>
<a href="#L47"> 47</a>
<a href="#L48"> 48</a>
<a href="#L49"> 49</a>
<a href="#L50"> 50</a>
<a href="#L51"> 51</a>
<a href="#L52"> 52</a>
<a href="#L53"> 53</a>
<a href="#L54"> 54</a>
<a href="#L55"> 55</a>
<a href="#L56"> 56</a>
<a href="#L57"> 57</a>
<a href="#L58"> 58</a>
<a href="#L59"> 59</a>
<a href="#L60"> 60</a>
<a href="#L61"> 61</a>
<a href="#L62"> 62</a>
<a href="#L63"> 63</a>
<a href="#L64"> 64</a>
<a href="#L65"> 65</a>
<a href="#L66"> 66</a>
<a href="#L67"> 67</a>
<a href="#L68"> 68</a>
<a href="#L69"> 69</a>
<a href="#L70"> 70</a>
<a href="#L71"> 71</a>
<a href="#L72"> 72</a>
<a href="#L73"> 73</a>
<a href="#L74"> 74</a>
<a href="#L75"> 75</a>
<a href="#L76"> 76</a>
<a href="#L77"> 77</a>
<a href="#L78"> 78</a>
<a href="#L79"> 79</a>
<a href="#L80"> 80</a>
<a href="#L81"> 81</a>
<a href="#L82"> 82</a>
<a href="#L83"> 83</a>
<a href="#L84"> 84</a>
<a href="#L85"> 85</a>
<a href="#L86"> 86</a>
<a href="#L87"> 87</a>
<a href="#L88"> 88</a>
<a href="#L89"> 89</a>
<a href="#L90"> 90</a>
<a href="#L91"> 91</a>
<a href="#L92"> 92</a>
<a href="#L93"> 93</a>
<a href="#L94"> 94</a>
<a href="#L95"> 95</a>
<a href="#L96"> 96</a>
<a href="#L97"> 97</a>
<a href="#L98"> 98</a>
<a href="#L99"> 99</a>
<a href="#L100">100</a>
<a href="#L101">101</a>
<a href="#L102">102</a>
<a href="#L103">103</a>
<a href="#L104">104</a>
<a href="#L105">105</a>
<a href="#L106">106</a>
<a href="#L107">107</a>
<a href="#L108">108</a>
<a href="#L109">109</a>
<a href="#L110">110</a>
<a href="#L111">111</a>
<a href="#L112">112</a>
<a href="#L113">113</a>
<a href="#L114">114</a>
<a href="#L115">115</a>
<a href="#L116">116</a>
<a href="#L117">117</a>
<a href="#L118">118</a>
<a href="#L119">119</a>
<a href="#L120">120</a>
<a href="#L121">121</a>
<a href="#L122">122</a>
<a href="#L123">123</a>
<a href="#L124">124</a>
<a href="#L125">125</a>
<a href="#L126">126</a>
<a href="#L127">127</a>
<a href="#L128">128</a>
<a href="#L129">129</a>
<a href="#L130">130</a>
<a href="#L131">131</a>
<a href="#L132">132</a>
<a href="#L133">133</a>
<a href="#L134">134</a>
<a href="#L135">135</a>
<a href="#L136">136</a>
<a href="#L137">137</a>
<a href="#L138">138</a>
<a href="#L139">139</a>
<a href="#L140">140</a>
<a href="#L141">141</a>
<a href="#L142">142</a>
<a href="#L143">143</a>
<a href="#L144">144</a>
<a href="#L145">145</a>
<a href="#L146">146</a>
<a href="#L147">147</a>
<a href="#L148">148</a>
<a href="#L149">149</a>
<a href="#L150">150</a>
<a href="#L151">151</a>
<a href="#L152">152</a>
<a href="#L153">153</a>
<a href="#L154">154</a>
<a href="#L155">155</a>
<a href="#L156">156</a>
<a href="#L157">157</a>
<a href="#L158">158</a>
<a href="#L159">159</a>
<a href="#L160">160</a>
<a href="#L161">161</a>
<a href="#L162">162</a>
<a href="#L163">163</a>
<a href="#L164">164</a>
<a href="#L165">165</a>
<a href="#L166">166</a>
<a href="#L167">167</a>
<a href="#L168">168</a>
<a href="#L169">169</a>
<a href="#L170">170</a>
<a href="#L171">171</a>
<a href="#L172">172</a>
<a href="#L173">173</a>
<a href="#L174">174</a>
<a href="#L175">175</a>
<a href="#L176">176</a>
<a href="#L177">177</a>
<a href="#L178">178</a>
<a href="#L179">179</a>
<a href="#L180">180</a>
<a href="#L181">181</a>
<a href="#L182">182</a>
<a href="#L183">183</a>
<a href="#L184">184</a>
<a href="#L185">185</a>
<a href="#L186">186</a>
<a href="#L187">187</a>
<a href="#L188">188</a>
<a href="#L189">189</a>
<a href="#L190">190</a>
<a href="#L191">191</a>
<a href="#L192">192</a>
<a href="#L193">193</a>
<a href="#L194">194</a>
<a href="#L195">195</a>
<a href="#L196">196</a>
<a href="#L197">197</a>
<a href="#L198">198</a>
<a href="#L199">199</a>
<a href="#L200">200</a>
<a href="#L201">201</a>
<a href="#L202">202</a>
<a href="#L203">203</a>
<a href="#L204">204</a>
<a href="#L205">205</a>
<a href="#L206">206</a>
<a href="#L207">207</a>
<a href="#L208">208</a>
<a href="#L209">209</a>
<a href="#L210">210</a>
<a href="#L211">211</a>
<a href="#L212">212</a>
<a href="#L213">213</a>
<a href="#L214">214</a>
<a href="#L215">215</a>
<a href="#L216">216</a>
<a href="#L217">217</a>
<a href="#L218">218</a>
<a href="#L219">219</a>
<a href="#L220">220</a>
<a href="#L221">221</a>
<a href="#L222">222</a>
<a href="#L223">223</a>
<a href="#L224">224</a>
<a href="#L225">225</a>
<a href="#L226">226</a>
<a href="#L227">227</a>
<a href="#L228">228</a>
<a href="#L229">229</a>
<a href="#L230">230</a>
<a href="#L231">231</a>
<a href="#L232">232</a>
<a href="#L233">233</a>
<a href="#L234">234</a>
<a href="#L235">235</a>
<a href="#L236">236</a>
<a href="#L237">237</a>
<a href="#L238">238</a>
<a href="#L239">239</a>
<a href="#L240">240</a>
<a href="#L241">241</a>
<a href="#L242">242</a>
<a href="#L243">243</a>
<a href="#L244">244</a>
<a href="#L245">245</a>
<a href="#L246">246</a>
<a href="#L247">247</a>
<a href="#L248">248</a>
<a href="#L249">249</a>
<a href="#L250">250</a>
<a href="#L251">251</a>
<a href="#L252">252</a>
<a href="#L253">253</a>
<a href="#L254">254</a>
<a href="#L255">255</a>
<a href="#L256">256</a>
<a href="#L257">257</a>
<a href="#L258">258</a>
<a href="#L259">259</a>
<a href="#L260">260</a>
<a href="#L261">261</a>
<a href="#L262">262</a>
<a href="#L263">263</a>
<a href="#L264">264</a>
<a href="#L265">265</a>
<a href="#L266">266</a>
<a href="#L267">267</a>
<a href="#L268">268</a>
<a href="#L269">269</a>
<a href="#L270">270</a>
<a href="#L271">271</a>
<a href="#L272">272</a>
<a href="#L273">273</a>
<a href="#L274">274</a>
<a href="#L275">275</a>
<a href="#L276">276</a>
<a href="#L277">277</a>
<a href="#L278">278</a>
<a href="#L279">279</a>
<a href="#L280">280</a>
<a href="#L281">281</a>
<a href="#L282">282</a>
<a href="#L283">283</a>
<a href="#L284">284</a>
<a href="#L285">285</a>
<a href="#L286">286</a>
<a href="#L287">287</a>
<a href="#L288">288</a>
<a href="#L289">289</a>
<a href="#L290">290</a>
<a href="#L291">291</a>
<a href="#L292">292</a>
<a href="#L293">293</a>
<a href="#L294">294</a>
<a href="#L295">295</a>
<a href="#L296">296</a>
<a href="#L297">297</a>
<a href="#L298">298</a>
<a href="#L299">299</a>
<a href="#L300">300</a>
<a href="#L301">301</a>
<a href="#L302">302</a>
<a href="#L303">303</a>
<a href="#L304">304</a>
<a href="#L305">305</a>
<a href="#L306">306</a>
<a href="#L307">307</a>
<a href="#L308">308</a>
<a href="#L309">309</a>
<a href="#L310">310</a>
<a href="#L311">311</a>
<a href="#L312">312</a>
<a href="#L313">313</a>
<a href="#L314">314</a>
<a href="#L315">315</a>
<a href="#L316">316</a>
<a href="#L317">317</a>
<a href="#L318">318</a>
<a href="#L319">319</a>
<a href="#L320">320</a>
<a href="#L321">321</a>
<a href="#L322">322</a>
<a href="#L323">323</a>
</pre>
<pre><code class="ocaml">open Core
open Turn
open Facelet
open Color
open Cube
open Consts
open Turn_stack
open Turn_stack.Let_syntax

type turn = Turn.t
type facelet = Facelet.t
type color = Color.t

  
let monadic_move (tn: turn) (c: Cube.t) : Cube.t Turn_stack.t =
  let%bind () = pus<span data-count="3388826">h</span> tn in
  <span data-count="3388826">r</span>eturn (mov<span data-count="3388826">e</span> c tn)

let monadic_move_seq (tn_seq: turn list) (c: Cube.t) : Cube.t Turn_stack.t =
  <span data-count="1186080">L</span>ist.fold ~init:(retur<span data-count="1186080">n</span> c) ~f:(fun accum tn -&gt; let%bind cube = accum in <span data-count="1876373">m</span>onadic_move tn cube) tn_seq


let is_color (cube : Cube.t) (color : color) (flet : facelet) : bool =
  <span data-count="38127091">e</span>qual_option Color.equal (Some color) @@ ge<span data-count="38127091">t</span> cube flet

(* Given the colors of the cubies, iterate over all cubies and apply the function f to each cubie.
  Before moving on to the next cube, it does the finishing move. *)
let for_each_cubie ~(cubie_colors: 'a list)
                  ~(adjacent_cubies: 'b list)
                  ~(color_selector: 'a -&gt; Cube.t -&gt; 'b -&gt; bool)
                  ~(get_first_facelet: 'b -&gt; facelet)
                  ~(f: Cube.t -&gt; facelet -&gt; Cube.t Turn_stack.t)
                  ~(finish_move: turn)
                  ~(cube: Cube.t) =
  <span data-count="279017">L</span>ist.fold cubie_colors ~init:(retur<span data-count="279017">n</span> cube) ~f:(fun cube c_tup -&gt; (* Fold through every color of cubie *)
    let%bind c = cube in (* Extract cube from monad *)
    <span data-count="1116068">a</span>djacent_cubies
    |&gt; List.filte<span data-count="1116068">r</span> ~f:(color_selecto<span data-count="1116068">r</span> c_tup c) (* limit to cubie that is exactly the desired color *)
    |&gt; List.hd_ex<span data-count="1116068">n</span> (* Gets only element--safe if the cube is well-formed *)
    |&gt; get_first_facele<span data-count="1116068">t</span> (* Get the facelet of the first color because the second color is implied *)
    |&gt; <span data-count="1116068">f</span> c (* Apply function on this facelet *)
    &gt;&gt;= monadic_mov<span data-count="1116068">e</span> finish_move (* Apply rotation/finish move so that the remaining colors can follow the same pattern *)
  )

(* Iterate over all edges by narrowing down the definition of a cubie *)
let for_each_edge ~(edge_colors: (color * color) list)
                  ~(f: Cube.t -&gt; facelet -&gt; Cube.t Turn_stack.t)
                  ~(finish_move: turn)
                  ~(cube: Cube.t) =
  <span data-count="239005">f</span>or_each_cubie ~cubie_colors:edge_colors
    ~adjacent_cubies:adjacent_edges
    ~color_selector:(fun (c1, c2) cube (f1, f2) -&gt; <span data-count="22944480">i</span>s_colo<span data-count="22944480">r</span> cube c1 f1 &amp;&amp; <span data-count="3824080">i</span>s_color cube c2 f2) (* match the two colors of the edge *)
    ~get_first_facelet:Tuple2.get1
    ~f:f
    ~finish_move:finish_move
    ~cube:cube


(* Will solve the yellow cross on the bottom of the cube.
  Strategy:
  i) Take it color-by-color i.e. solve Re, Bl, Or, then Gr sides
  ii) Find the Ye/[other color] piece by checking each possible edge
  iii) Move the edge piece into the F8/D2 position (i.e. FD) 
  iv) Do D' so that solving the next color puts in the proper position respective to the previous color
  v) All four colors means that there are four D' moves, so the cross is orientied correctly in the end.

  See consts.ml for definition of get_turns_to_FD used here.
  *)
let solve_yellow_cross (cube: Cube.t) : Cube.t Turn_stack.t =
  <span data-count="50013">f</span>or_each_edge ~edge_colors:[(Ye, Re); (Ye, Bl); (Ye, Or); (Ye, Gr)] (* Looking for yellow edge pieces *)
                ~f:(fun cube flet -&gt; <span data-count="200052">f</span>let |&gt; get_turns_to_F<span data-count="200052">D</span> |&gt; Fn.flip monadic_move_seq cube) (* With each edge piece, will put in Front/Down position *)
                ~finish_move:D' (* Rotate bottom layer once between colors *)
                ~cube:cube

let for_each_corner ~(corner_colors: (color * color * color) list)
                ~(f: Cube.t -&gt; facelet -&gt; Cube.t Turn_stack.t)
                ~(finish_move: turn)
                ~(cube: Cube.t) =
  <span data-count="40012">f</span>or_each_cubie ~cubie_colors:corner_colors
                  ~adjacent_cubies:adjacent_corners
                  ~color_selector:(fun (c1, c2, c3) cube (f1, f2, f3) -&gt; <span data-count="7682304">i</span>s_colo<span data-count="7682304">r</span> cube c1 f1 &amp;&amp; <span data-count="1280384">i</span>s_colo<span data-count="1280384">r</span> cube c2 f2 &amp;&amp; <span data-count="320096">i</span>s_color cube c3 f3)
                  ~get_first_facelet:Tuple3.get1
                  ~f:f
                  ~finish_move:finish_move
                  ~cube:cube

(* Solves the yellow corners without affecting the edges on the bottom (i.e. doesn't mess up yellow cross)
  Method:
  i) Locate desired corner 
  ii) Put in bottom right corner
  iii) Rotate bottom face "left" so that next color can fit in bottom right
  iv) Repeat

  See consts.ml for definition of get_turns_to_DFR used here.
*)
let solve_yellow_corners (cube : Cube.t) : Cube.t Turn_stack.t =
  <span data-count="40012">f</span>or_each_corner ~corner_colors:[(Ye, Re, Bl); (Ye, Bl, Or); (Ye, Or, Gr); (Ye, Gr, Re)] (* Look at all yellow corners *)
                  ~f:(fun cube flet -&gt; <span data-count="160048">f</span>let |&gt; get_turns_to_DF<span data-count="160048">R</span> |&gt; Fn.flip monadic_move_seq cube) (* Solve this corner by putting it in bottom right *)
                  ~finish_move:D' (* Rotate bottom face so that next corner can go in bottom right *)
                  ~cube:cube

(* Is true iff there is some edge in the top layer that has no white facelet. *)
let has_non_white_edge_in_top (cube: Cube.t) : bool =
  <span data-count="158981">[</span>(U8, F2); (U6, R2); (U2, B2); (U4, L2)] (* These are exactly the top edges. *)
  |&gt; List.filte<span data-count="158981">r</span> ~f:(fun (f1, f2) -&gt; <span data-count="635924">n</span>o<span data-count="635924">t</span> @@ is_colo<span data-count="635924">r</span> cube Wh f1 &amp;&amp; <span data-count="191097">n</span>ot @@ is_colo<span data-count="191097">r</span> cube Wh f2) (* limit to edges with no white *)
  |&gt; List.is_empt<span data-count="158981">y</span>
  |&gt; not

(* Solves the edges in the middle layer of the cube so that first two layers are solved if the
    yellow face was already solved.
  Method:
  i) Consider each edge in the top layer that has no white
  ii) Rotate cube to match with center color
  iii) Rotate top layer accordingly
  iv) Fit in FR
  v) Repeat

  See consts.ml for definition of get_turns_top_to_FR used here.
*)
let rec solve_middle_edges_in_top (cube : Cube.t) : Cube.t Turn_stack.t =
  <span data-count="158981">f</span>or_each_edge ~edge_colors:[(Re, Bl); (Bl, Or); (Or, Gr); (Gr, Re)] (* Looking for middle-layer edge pieces *)
                ~f:(fun cube flet -&gt; <span data-count="635924">f</span>let |&gt; get_turns_top_to_F<span data-count="635924">R</span> |&gt; Fn.flip monadic_move_seq cube) (* Move the edge to the front right position iff it's in the top layer *)
                ~finish_move:Y (* Finish with a whole rotation because we need the front right edge piece to move *)
                ~cube:cube
  &gt;&gt;= fun c -&gt; <span data-count="158981">i</span>f has_non_white_edge_in_top c then <span data-count="8926">s</span>olve_middle_edges_in_top c else <span data-count="150055">r</span>eturn c (* Repeat until no more white in top layer *)

(* Rotates the cube until the front center facelet is the desired color.
  Note: this will loop infinitely if the color is Ye or Wh, but that will never happen in the scope of this project. *)
let rec reset_center (color: color option) (cube: Cube.t) : Cube.t Turn_stack.t =
  <span data-count="600220">i</span>f equal_option Color.equal color @@ ge<span data-count="600220">t</span> cube F5 then <span data-count="240088">r</span>eturn cube (* Center is aligned. Nothing to do *)
  else <span data-count="360132">m</span>onadic_mov<span data-count="360132">e</span> Y cube &gt;&gt;= reset_cente<span data-count="360132">r</span> color (* Center not aligned. Rotate and check if that worked *)

(* Puts the edge in the middle layer into FR s.t. flet is facing forward.
  This isn't as clunky as the other turn sequences, so I leave it here. *)
let put_middle_edge_in_FR (cube : Cube.t) (flet: facelet) : Cube.t Turn_stack.t =
  <span data-count="120044">l</span>et center_color = get cube F5 in
  <span data-count="120044">l</span>et move_to_top_seq = [R; U; R'; U'; F'; U'; F] in (* moves to top from FR *)
  let turn_seq : turn list = (* This will either solve the piece or move into top layer *)
    match flet with
    | <span data-count="2053">R</span>4 -&gt; [F2; U2; R'; F2; R; U2; F; U'; F] (* Correct position except piece is flipped *)
    | <span data-count="246">R</span>6 | <span data-count="2618">B</span>4 -&gt; Y :: move_to_top_seq @ [Y'] (* Move back right into top *)
    | <span data-count="430">B</span>6 | <span data-count="165">L</span>4 -&gt; Y2 :: move_to_top_seq @ [Y2] (* Move back left into top *)
    | <span data-count="138">L</span>6 | <span data-count="1573">F</span>4 -&gt; Y' :: move_to_top_seq @ [Y] (* Move front left into top *)
    | <span data-count="112821">F</span>6 -&gt; [] (* Is solved *)
    | <span data-count="0">_</span> -&gt; failwith "Unexpected position for edge. Expected in middle layer."
  in
  monadic_move_se<span data-count="120044">q</span> turn_seq cube
  &gt;&gt;<span data-count="120044">=</span> reset_cente<span data-count="120044">r</span> (Some Re) (* Rotate to get the red facing forward so solving from top layer works properly *)
  &gt;&gt;<span data-count="120044">=</span> solve_middle_edges_in_top (* May need to solve a piece from the top layer, so do that now *)
  &gt;&gt;= reset_cente<span data-count="120044">r</span> center_color (* Rotate until center is lined up again because we moved out of position *)

(* Assuming there are no non-white edges in the top layer, solve the middle edges.
  That is, all edges that need to be in the middle are already in the middle, and they
  just need to be moved around (or they are solved).
  Method:
  i) Locate each edge that is NOT solved
  ii) Move that edge into the top layer 
  iii) Solve the middle edges that are in the top.
  iv) Repeat.
  Note that I can't just move edges out of the middle and then solve the top because of the way edges get replaced.
  In fact, even though this seems like a long method, moving edges from top layer into middle layer first gets a lot
  of edges into the top layer and typically solves the middle layer altogether. I need this step in case we're unlucky
  and there are some flipped pieces.
*)
let solve_middle_edges_in_side (cube : Cube.t) : Cube.t Turn_stack.t =
  <span data-count="30011">f</span>or_each_edge ~edge_colors:[(Re, Bl); (Bl, Or); (Or, Gr); (Gr, Re)]
                ~f:put_middle_edge_in_FR (* Move the edge to the front right position *)
                ~finish_move:Y (* Finish with a whole rotation because we need the front right edge piece to move *)
                ~cube:cube

let has_all_white (cube: Cube.t) (flets: facelet list) : bool =
  <span data-count="594488">L</span>ist.for_all flets ~f:(fun flet -&gt; <span data-count="1229875">i</span>s_color cube Wh flet)

(* For final layer, I will take a different approach. I will do the 2Look OLL
  (orient last layer to get all white facing up), which requires a lot of pattern
  matching but is much faster than solving it similarly to the yellow face on the bottom.

  See consts.ml for defintion of oll_perms used here.
*)
let rec solve_OLL (cube : Cube.t) : Cube.t Turn_stack.t =
  <span data-count="65988">l</span>et turn_seq = List.find oll_perms ~f:(fun (ls, _) -&gt; <span data-count="594488">h</span>as_all_white cube ls) in
  <span data-count="65988">m</span>atch turn_seq with
  | <span data-count="40847">S</span>ome (_, seq) when List.is_empt<span data-count="40847">y</span> seq -&gt; <span data-count="20011">r</span>eturn cube (* Cube matched the solved configuration, so return *)
  | <span data-count="20836">S</span>ome (_, seq) -&gt; monadic_move_se<span data-count="20836">q</span> seq cube &gt;&gt;= solve_OLL (* Matched an unsolved configuration, so do sequence and repeat *)
  | <span data-count="25141">N</span>one -&gt; monadic_mov<span data-count="25141">e</span> U cube &gt;&gt;= solve_OLL (* Didn't match any configuration, so rotate top face and try again *)

(* Given a list of colors, find the index of the first Re.
  This is to be used when checking the color of the outside facelets of the top layer
  after the OLL step [so first two layers are solved, and top face is all white].
  Thus we may assume the cube is well-formed *)
let get_red_index (cs: color list) : int =
  <span data-count="49189">c</span>s
  |&gt; List.find<span data-count="49189">i</span> ~f:(fun _ c -&gt; <span data-count="120108">C</span>olor.equal Re c)
  |&gt; Option.valu<span data-count="49189">e</span> ~default:(0, Wh) (* default is arbitrary because it will never be needed in uses of this function *)
  |&gt; Tuple2.get1

(* Given a well-formed cube, return true iff the top edges are oriented properly,
  disregarding the starting color.
  i.e. they go Re -&gt; Bl -&gt; Or -&gt; Gr and wrap around *)
let are_top_edges_solved (cube: Cube.t) : bool =
  <span data-count="49114">l</span>et cs = [F2; R2; B2; L2]
    |&gt; List.ma<span data-count="49114">p</span> ~f:(ge<span data-count="49114">t</span> cube)
    |&gt; List.filter_opt (* we now have the colors of the outside edges *)
  in <span data-count="49114">l</span>et ri = get_red_index cs in
  <span data-count="49114">L</span>ist.ini<span data-count="49114">t</span> 4 ~f:(fun i -&gt; <span data-count="196456">L</span>ist.nth_exn cs @@ (ri + i) <span data-count="196456">%</span> 4) (* use the index of red to reorder list to have red first *)
  |&gt; List.equal Color.equal [Re; Bl; Or; Gr] (* compare with expected order of colors *)


(* Now the white face is solved, and I only need to permute the cubies in the top layer 
  so that the sides are solved.
  
  See the algorithms here: http://www.cubewhiz.com/2lookpll.php. I convert them to work with
  the turns used in this project.

  I'll take a different approach yet again. This time, I will brute-force it even more by trying
  each of the algorithms and seeing if they work. There are four algorithms to permute the edges
  and three algorithms to permute the corners. That's not so bad.
  *)
let rec solve_PLL_edges (cube: Cube.t) : Cube.t Turn_stack.t =
  <span data-count="12277">l</span>et soln = pll_edge_algorithms
    |&gt; List.ma<span data-count="12277">p</span> ~f:(fun ls -&gt; <span data-count="49108">m</span>onadic_move_seq ls cube)
    |&gt; List.filter ~f:(fun m -&gt; <span data-count="49108">r</span>un @@ let%bind cube = m in <span data-count="49108">r</span>eturn (are_top_edges_solve<span data-count="49108">d</span> cube))
  in <span data-count="12277">m</span>atch soln with
  | <span data-count="2266">[</span>] -&gt; monadic_mov<span data-count="2266">e</span> U cube &gt;&gt;= solve_PLL_edges (* None of these algorithms solved the edges. Rotate once and try again *)
  | <span data-count="10011">m</span> :: [] -&gt; m (* Found a solution. *)
  | <span data-count="0">_</span> -&gt; failwith "Unexpected orientation after OLL; unsolvable edges by PLL"


(* Given a well-formed cube, return true iff the top layer is solved, disregarding orientation.
  That is, the colors on the outside facelets of the top layer are as expected, but they
  may not be aligned correctly s.t. the cube is solved.
*)
let is_top_layer_solved (cube: Cube.t) : bool =
  <span data-count="75">l</span>et cs = [F1; F2; F3; R1; R2; R3; B1; B2; B3; L1; L2; L3]
    |&gt; List.ma<span data-count="75">p</span> ~f:(ge<span data-count="75">t</span> cube)
    |&gt; List.filter_opt (* we know have the colors of all outside facelets *)
  in <span data-count="75">l</span>et ri = get_red_index cs in
  <span data-count="75">L</span>ist.ini<span data-count="75">t</span> 12 ~f:(fun i -&gt; <span data-count="900">L</span>ist.nth_exn cs @@ (ri + i) <span data-count="900">%</span> 12) (* use the index of red to reorder list to have red first *)
  |&gt; List.equal Color.equal [Re; Re; Re; Bl; Bl; Bl; Or; Or; Or; Gr; Gr; Gr] (* compare with expected order of colors *)


(* The final step is to solve the corners once the top face is all white and the edges
  are oriented correctly. Take the same approach as solving PLL edges.
  *)
let rec solve_PLL_corners (cube: Cube.t) : Cube.t Turn_stack.t =
  <span data-count="17">l</span>et soln = pll_corner_algorithms
    |&gt; List.ma<span data-count="17">p</span> ~f:(fun ls -&gt; <span data-count="68">m</span>onadic_move_seq ls cube)
    |&gt; List.filter ~f:(fun m -&gt; <span data-count="68">r</span>un @@ let%bind cube = m in <span data-count="68">r</span>eturn (is_top_layer_solve<span data-count="68">d</span> cube)) (* Limit to algorithms that solved the top layer *)
  in <span data-count="17">m</span>atch soln with
  | <span data-count="6">[</span>] -&gt; monadic_mov<span data-count="6">e</span> U cube &gt;&gt;= solve_PLL_corners (* None of these algorithms solved the edges. Rotate once and try again *)
  | <span data-count="11">m</span> :: [] -&gt; m (* Found a solution. *)
  | <span data-count="0">_</span> -&gt; failwith "Unexpected orientation after OLL; unsolvable corners by PLL"

(* Given a completely solved cube except for the rotation of the top face,
  finish solving the cube. *)
let rec solve_top_orientation (cube: Cube.t) : Cube.t Turn_stack.t =
  <span data-count="18851">i</span>f is_color cube Re F2 then <span data-count="10011">r</span>eturn cube (* We're done! Hooray! *)
  else <span data-count="8840">m</span>onadic_mov<span data-count="8840">e</span> U cube &gt;&gt;= solve_top_orientation (* Red doesn't line up, turn top face until it does. *)

(* May be best to convert to move equivalences, then block into all of same type in a row, then convert back. *)
let parse (t1, t2 : turn * turn) : turn list =
  (* Yes, long and messy as usual in this program *)
  <span data-count="60047">m</span>atch t1, t2 with
  | <span data-count="89">R</span>, R' | <span data-count="87">B</span>, B' | <span data-count="84">L</span>, L' | <span data-count="91">F</span>, F' | <span data-count="99">U</span>, U' | <span data-count="88">D</span>, D' | <span data-count="91">Y</span>, Y'
  | <span data-count="85">R</span>', R | <span data-count="84">B</span>', B | <span data-count="88">L</span>', L | <span data-count="86">F</span>', F | <span data-count="86">U</span>', U | <span data-count="111">D</span>', D | <span data-count="92">Y</span>', Y
  | <span data-count="72">R</span>2, R2 | <span data-count="91">B</span>2, B2 | <span data-count="117">L</span>2, L2 | <span data-count="87">F</span>2, F2 | <span data-count="101">U</span>2, U2 | <span data-count="70">D</span>2, D2 | <span data-count="92">Y</span>2, Y2 -&gt; []
  | <span data-count="80">R</span>, R2 | <span data-count="84">R</span>2, R -&gt; [R']
  | <span data-count="86">B</span>, B2 | <span data-count="77">B</span>2, B -&gt; [B']
  | <span data-count="90">L</span>, L2 | <span data-count="92">L</span>2, L -&gt; [L']
  | <span data-count="80">F</span>, F2 | <span data-count="77">F</span>2, F -&gt; [F']
  | <span data-count="72">U</span>, U2 | <span data-count="91">U</span>2, U -&gt; [U']
  | <span data-count="84">D</span>, D2 | <span data-count="93">D</span>2, D -&gt; [D']
  | <span data-count="106">Y</span>, Y2 | <span data-count="88">Y</span>2, Y -&gt; [Y']
  | <span data-count="86">R</span>', R2 | <span data-count="85">R</span>2, R' -&gt; [R] (* Cannot convert to string and do this more algorithmically because of issues with ' character *)
  | <span data-count="86">B</span>', B2 | <span data-count="77">B</span>2, B' -&gt; [B]
  | <span data-count="75">L</span>', L2 | <span data-count="95">L</span>2, L' -&gt; [L]
  | <span data-count="103">F</span>', F2 | <span data-count="86">F</span>2, F' -&gt; [F]
  | <span data-count="81">U</span>', U2 | <span data-count="102">U</span>2, U' -&gt; [U]
  | <span data-count="89">D</span>', D2 | <span data-count="89">D</span>2, D' -&gt; [D]
  | <span data-count="84">Y</span>', Y2 | <span data-count="85">Y</span>2, Y' -&gt; [Y]
  | <span data-count="86">R</span>, R | <span data-count="87">R</span>', R' -&gt; [R2]
  | <span data-count="63">B</span>, B | <span data-count="82">B</span>', B' -&gt; [B2]
  | <span data-count="87">L</span>, L | <span data-count="85">L</span>', L' -&gt; [L2]
  | <span data-count="93">F</span>, F | <span data-count="84">F</span>', F' -&gt; [F2]
  | <span data-count="85">U</span>, U | <span data-count="104">U</span>', U' -&gt; [U2]
  | <span data-count="90">D</span>, D | <span data-count="83">D</span>', D' -&gt; [D2]
  | <span data-count="103">Y</span>, Y | <span data-count="68">Y</span>', Y' -&gt; [Y2]
  | <span data-count="54533">_</span> -&gt; [t1; t2] (* catch the remaining cases by just putting back on stack*)

(* Simplify the turn list by replacing series of moves with identical moves.
  e.g. R R2 &lt;=&gt; R' *)
let rec simplify (ls : turn list) : turn list =
  <span data-count="13043">l</span>et res = List.fol<span data-count="13043">d</span> ls ~init:[] ~f:(fun stack next -&gt;
    <span data-count="70988">m</span>atch stack with
    | <span data-count="60047">t</span>op :: tail -&gt; pars<span data-count="60047">e</span> (next, top) @ tail
    | <span data-count="10941">[</span>] -&gt; [next])
  |&gt; List.rev (* Must reverse because used a stack, which reversed the order *)
  in
  <span data-count="13043">i</span>f List.lengt<span data-count="13043">h</span> res = List.lengt<span data-count="13043">h</span> ls then <span data-count="10013">r</span>es (* If length was not changed, then it's fully simplified *)
  else <span data-count="3030">s</span>implify res (* Length was changed, so try again to reduce further *)

let solve (cube: Cube.t) : Cube.t Turn_stack.t =
  <span data-count="11">c</span>ube
  |&gt; solve_yellow_cros<span data-count="11">s</span>
  &gt;&gt;<span data-count="11">=</span> solve_yellow_corners
  &gt;&gt;<span data-count="11">=</span> solve_middle_edges_in_top
  &gt;&gt;<span data-count="11">=</span> solve_middle_edges_in_side
  &gt;&gt;<span data-count="11">=</span> solve_OLL
  &gt;&gt;<span data-count="11">=</span> solve_PLL_edges
  &gt;&gt;<span data-count="11">=</span> solve_PLL_corners
  &gt;&gt;= solve_top_orientation

let monadic_main (cube : Cube.t) : (turn list) Turn_stack.t =
  let%bind _ = solv<span data-count="1">e</span> cube in (* assign to _ because we assume cube will be solved, so no need to return it *)
  let%bind s = get_rev_stack in
  <span data-count="1">r</span>eturn @@ simplif<span data-count="1">y</span> s (* At this point I really don't need the monad *)

let get_solution (cube: Cube.t) : (turn list, string) result =
  <span data-count="1">t</span>ry
    Ok (ru<span data-count="1">n</span> @@ monadic_mai<span data-count="1">n</span> cube)
  with <span data-count="0">_</span> -&gt; (* Ignore exception and assume it's from non-well-formedness because my tests never throw an error when cube is well-formed *)
    Error "Cube is not well-formed. It could not be solved. <span data-count="10">"</span>
;;
</code></pre>
      </div>
    </div>
    <script src="../coverage.js"></script>
  </body>
</html>
