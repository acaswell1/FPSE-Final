open Core;;
open OUnit2;;
open Facelet;;
open Turn;;
open Color;;
open Cube;;
open Solver;;
open Turn_stack.Let_syntax;;

type color = Color.t
type turn = Turn.t

let c = create_solved ();;

let do_colors_match_facelets cs fs cube =
  fs
  |> List.map ~f:(fun flet -> get cube flet)
  |> List.filter_opt (* extract actual colors form options *)
  |> List.zip_exn cs (* zip actual colors with expected colors *)
  |> List.for_all ~f:(fun (c1, c2) -> Color.equal c1 c2)

let is_yellow_cross_solved =
  do_colors_match_facelets [Ye; Ye; Ye; Ye; Re; Bl; Or; Gr] [D2; D4; D6; D8; F8; R8; B8; L8]


let is_yellow_face_solved cube =
  (is_yellow_cross_solved cube) &&
  do_colors_match_facelets [Ye; Ye; Ye; Ye; Re; Bl; Bl; Or; Or; Gr; Gr; Re] [D1; D3; D7; D9; F9; R7; R9; B7; B9; L7; L9; F7] cube


let is_F2L_solved cube =
  (is_yellow_face_solved cube) &&
  do_colors_match_facelets [Re; Bl; Bl; Or; Or; Gr; Gr; Re] [F6; R4; R6; B4; B6; L4; L6; F4] cube (* these are the edge pieces in middle layer *)


let is_OLL_solved cube =
  (is_F2L_solved cube) &&
  do_colors_match_facelets (List.init 9 ~f:(fun _ -> Wh)) [U1; U2; U3; U4; U5; U6; U7; U8; U9] cube

let are_PLL_edges_solved cube =
  (is_OLL_solved cube) &&
  do_colors_match_facelets [Re; Bl; Or; Gr] [F2; R2; B2; L2] cube
;;

let turn_list_gen = (List.quickcheck_generator Turn.quickcheck_generator);;

(* Turn a solved cube according to the turn list, then use solver to solve through
  the desired stage, then make sure it worked properly using checker. *)
let my_test (solver: Cube.t -> Cube.t Turn_stack.t) (checker: Cube.t -> bool) (turn_list: turn list) : bool =
  turn_list
  |> List.filter ~f:(fun t -> match t with Y | Y2 | Y' -> false | _ -> true) (* ignore any Y moves generated by quickcheck. *)
  |> move_seq (create_solved ())
  |> solver
  |> Turn_stack.run
  |> checker

let test_solve_yellow_cross _ =
  let test = my_test solve_yellow_cross is_yellow_cross_solved in
  Quickcheck.test turn_list_gen ~f:(fun ls -> assert (test ls)); (* This tests a #$%^-ton of random cube configurations *)
;;

(* Relies on solving the yellow cross *)
let test_solve_yellow_face _ =
  let test = my_test (fun c -> c |> solve_yellow_cross >>= solve_yellow_corners) is_yellow_face_solved in
  Quickcheck.test turn_list_gen ~f:(fun ls -> assert (test ls));
;;

(* Relies on solving yellow face. Test first two layers together rather than testing putting
  all top edges into proper positions because that would be a rather weak test. *)
let test_solve_F2L _ =
  let test = my_test (fun c ->
    c
    |> solve_yellow_cross
    >>= solve_yellow_corners
    >>= solve_middle_edges_in_top
    >>= solve_middle_edges_in_side) is_F2L_solved
  in
  Quickcheck.test turn_list_gen ~f:(fun ls -> assert (test ls));
;;

(* Relies on solving first two layers. When OLL is solved, the first two layers are solved and
  the top face is all white. *)
let test_solve_OLL _ =
  let test = my_test (fun c ->
    c
    |> solve_yellow_cross
    >>= solve_yellow_corners
    >>= solve_middle_edges_in_top
    >>= solve_middle_edges_in_side
    >>= solve_OLL) is_OLL_solved
  in
  Quickcheck.test turn_list_gen ~f:(fun ls -> assert (test ls));
;;

let test_solve_PLL_edges _ =
  let test = my_test (fun c ->
    c
    |> solve_yellow_cross
    >>= solve_yellow_corners
    >>= solve_middle_edges_in_top
    >>= solve_middle_edges_in_side
    >>= solve_OLL
    >>= solve_PLL_edges
    >>= solve_top_orientation) are_PLL_edges_solved
    (* tack on solving top orientation to make it easy to check if edges are solved *)
  in
  Quickcheck.test turn_list_gen ~f:(fun ls -> assert (test ls));
;;

(* Can ignore PLL solve because that's the final step, so just test the whole thing. *)
let test_full_solve _ =
  let test = my_test solve is_solved in
  Quickcheck.test ~trials:10 turn_list_gen ~f:(fun ls -> assert (test ls));
;;

let solving_tests = 
  "Steps tests" >: test_list [
    "Yellow cross" >:: test_solve_yellow_cross;
    "Yellow face" >:: test_solve_yellow_face;
    "F2L" >:: test_solve_F2L;
    "OLL" >:: test_solve_OLL;
    "PLL edges" >:: test_solve_PLL_edges;
    "Full" >::test_full_solve;
  ]
;;

let yellow_cross_invariant _ =
  assert_equal true (create_solved () |> solve_yellow_cross |> Turn_stack.run |> is_yellow_cross_solved);
;;

let yellow_face_invariant _ =
  assert_equal true (create_solved () |> solve_yellow_cross >>= solve_yellow_corners |> Turn_stack.run |> is_yellow_face_solved);
;;

let test_are_top_edges_solved _ =
  assert_equal true (create_solved () |> are_top_edges_solved);
  assert_equal true (create_solved () |> Fn.flip move U |> are_top_edges_solved);
  assert_equal true (create_solved () |> Fn.flip move U2 |> are_top_edges_solved);
  assert_equal true (create_solved () |> Fn.flip move U' |> are_top_edges_solved);
  let s = List.nth_exn Consts.pll_edge_algorithms 1 in
  assert_equal false (create_solved () |> Fn.flip move_seq s |> are_top_edges_solved);
  let s = List.nth_exn Consts.pll_corner_algorithms 1 in
  assert_equal true (create_solved () |> Fn.flip move_seq s |> are_top_edges_solved);
;;

let test_is_top_layer_solved _ =
  assert_equal true (create_solved () |> is_top_layer_solved);
  assert_equal true (create_solved () |> Fn.flip move U |> is_top_layer_solved);
  assert_equal true (create_solved () |> Fn.flip move U2 |> is_top_layer_solved);
  assert_equal true (create_solved () |> Fn.flip move U' |> is_top_layer_solved);
  assert_equal false (create_solved () |> Fn.flip move F |> is_top_layer_solved);
  let s = List.nth_exn Consts.pll_edge_algorithms 1 in
  assert_equal false (create_solved () |> Fn.flip move_seq s |> is_top_layer_solved);
  let s = List.nth_exn Consts.pll_corner_algorithms 1 in
  assert_equal false (create_solved () |> Fn.flip move_seq s |> is_top_layer_solved);
;;

let test_solved_cube_invariant _ =
  let s = match get_solution (create_solved ()) with Ok ls -> ls | _ -> failwith "Unexpected error" in
  assert_equal [] s;
;;

let invariant_tests =
  "Invariant tests" >: test_list [
    "Yellow cross invariant" >:: yellow_cross_invariant;
    "Yellow face invariant" >:: yellow_face_invariant;
    "Are top edges solved" >:: test_are_top_edges_solved;
    "Is top solved" >:: test_is_top_layer_solved;
    "Cube already solved" >:: test_solved_cube_invariant
  ]
;;


let test_simplify_easy_move_equivalences _ =
  assert_equal [] @@ simplify [R; R'];
  assert_equal [R'] @@ simplify [R; R2];
  assert_equal [R2] @@ simplify [R; R];
  assert_equal [R2] @@ simplify [R'; R'];
;;

let test_triple_equivalences _ =
  assert_equal [R] @@ simplify [R'; R'; R'];
  assert_equal [R2] @@ simplify [R; R'; R2];
  assert_equal [R'] @@ simplify [R; R; R];
  assert_equal [] @@ simplify [R; R2; R];
;;

(* Requires no double simplification. One pass through should simplify these longer sequences *)
let test_medium_simplifications _ =
  assert_equal [R; U; D'] @@ simplify [R; D; D'; D; D'; U; R'; R; L; L'; D2; D];
  assert_equal [B'; L; D'] @@ simplify [B; B'; B2; B; L; U; U2; U; D'];
;;

(* Requires multiple passes to catch all simplifications *)
let test_hard_simplifications _ =
  assert_equal [D'] @@ simplify [R; D; D'; D; D'; R'; U; R'; R; U'; L; L'; D2; D]; (* Should only take two passes *)
  assert_equal [B] @@ simplify [U; B; B'; L'; B2; B; B; L; U; U2; B]; (* Should take three passes *)
;;

let test_simplify_gives_same_cube _ =
  let my_test turns =
    let c_normal = move_seq (create_solved ()) turns in
    let c_simp = move_seq (create_solved ()) (simplify turns) in
    equal_cube c_normal c_simp
  in
  Quickcheck.test turn_list_gen ~f:(fun ls -> assert (my_test ls));
;;

let simplify_tests = 
  "Simplify tests" >: test_list [
    "Easy move equivalences" >:: test_simplify_easy_move_equivalences;
    "Triple move equivalences" >:: test_triple_equivalences;
    "Medium simplifications" >:: test_medium_simplifications;
    "Hard simplifications" >:: test_hard_simplifications;
    "Simplify preserves cube" >:: test_simplify_gives_same_cube;
  ]
;;

let series =
  "All tests" >::: [
    solving_tests;
    invariant_tests;
    simplify_tests;
  ]
;;

let () =
  run_test_tt_main series