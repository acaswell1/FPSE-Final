open Core;;
open OUnit2;;
open Facelet;;
open Turn;;
open Color;;
open Cube;;
open Solver;;
open Turn_stack.Let_syntax;;

type color = Color.t

let c = create_solved ();;

let do_colors_match_facelets cs fs cube =
  fs
  |> List.map ~f:(fun flet -> get cube flet)
  |> List.filter_opt (* extract actual colors form options *)
  |> List.zip_exn cs (* zip actual colors with expected colors *)
  |> List.for_all ~f:(fun (c1, c2) -> Color.equal c1 c2)

let is_yellow_cross_solved =
  do_colors_match_facelets [Ye; Ye; Ye; Ye; Re; Bl; Or; Gr] [D2; D4; D6; D8; F8; R8; B8; L8]
;;

let is_yellow_face_solved cube =
  (is_yellow_cross_solved cube) &&
  do_colors_match_facelets [Ye; Ye; Ye; Ye; Re; Bl; Bl; Or; Or; Gr; Gr; Re] [D1; D3; D7; D9; F9; R7; R9; B7; B9; L7; L9; F7] cube
;;

let turn_list_gen = (List.quickcheck_generator Turn.quickcheck_generator);;

(* Turn a solved cube according to the turn list, then use solver to solve through
  the desired stage, then make sure it worked properly using checker. *)
let my_test (solver: Cube.t -> Cube.t Turn_stack.t) (checker: Cube.t -> bool) (turn_list: turn list) : bool =
  turn_list
  |> List.filter ~f:(fun t -> match t with Y | Y2 | Y' -> false | _ -> true) (* ignore any Y moves generated by quickcheck. *)
  |> move_seq (create_solved ())
  |> solver
  |> Solver.Turn_stack.run
  |> checker

let test_solve_yellow_cross _ =
  let test = my_test solve_yellow_cross is_yellow_cross_solved in
  Quickcheck.test turn_list_gen ~f:(fun ls -> assert (test ls)); (* This tests a #$%^-ton of random cube configurations *)
;;

(* Relies on solving the yellow cross *)
let test_solve_yellow_face _ =
  let test = my_test (fun c -> c |> solve_yellow_cross >>= solve_yellow_corners) is_yellow_face_solved in
  Quickcheck.test turn_list_gen ~f:(fun ls -> assert (test ls));
;;

let solving_steps_tests = 
  "Steps tests" >: test_list [
    "Yellow cross" >:: test_solve_yellow_cross;
    "Yellow face" >:: test_solve_yellow_face;
  ]
;;

let yellow_cross_invariant _ =
  assert_equal true (create_solved () |> solve_yellow_cross |> Solver.Turn_stack.run |> is_yellow_cross_solved);
;;

let invariant_tests =
  "Invariant tests" >: test_list [
    "Yellow cross invariant" >:: yellow_cross_invariant;
  ]
;;


let test_simplify_easy_move_equivalences _ =
  assert_equal [] @@ simplify [R; R'];
  assert_equal [R'] @@ simplify [R; R2];
  assert_equal [R2] @@ simplify [R; R];
  assert_equal [R2] @@ simplify [R'; R'];
;;

let test_triple_equivalences _ =
  assert_equal [R] @@ simplify [R'; R'; R'];
  assert_equal [R2] @@ simplify [R; R'; R2];
  assert_equal [R'] @@ simplify [R; R; R];
  assert_equal [] @@ simplify [R; R2; R];
;;

(* Requires no double simplification. One pass through should simplify these longer sequences *)
let test_medium_simplifications _ =
  assert_equal [R; U; D'] @@ simplify [R; D; D'; D; D'; U; R'; R; L; L'; D2; D];
  assert_equal [B'; L; D'] @@ simplify [B; B'; B2; B; L; U; U2; U; D'];
;;

(* Requires multiple passes to catch all simplifications *)
let test_hard_simplifications _ =
  assert_equal [D'] @@ simplify [R; D; D'; D; D'; R'; U; R'; R; U'; L; L'; D2; D]; (* Should only take two passes *)
  assert_equal [B] @@ simplify [U; B; B'; L'; B2; B; B; L; U; U2; B]; (* Should take three passes *)
;;

let test_simplify_gives_same_cube _ =
  let my_test turns =
    let c_normal = move_seq (create_solved ()) turns in
    let c_simp = move_seq (create_solved ()) (simplify turns) in
    equal_cube c_normal c_simp
  in
  Quickcheck.test turn_list_gen ~f:(fun ls -> assert (my_test ls));
;;

let simplify_tests = 
  "Simplify tests" >: test_list [
    "Easy move equivalences" >:: test_simplify_easy_move_equivalences;
    "Triple move equivalences" >:: test_triple_equivalences;
    "Medium simplifications" >:: test_medium_simplifications;
    "Hard simplifications" >:: test_hard_simplifications;
    "Simplify preserves cube" >:: test_simplify_gives_same_cube;
  ]
;;

let series =
  "All tests" >::: [
    solving_steps_tests;
    invariant_tests;
    simplify_tests;
  ]
;;

let () =
  run_test_tt_main series